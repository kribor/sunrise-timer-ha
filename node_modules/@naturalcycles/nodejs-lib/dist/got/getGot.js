"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGot = void 0;
const js_lib_1 = require("@naturalcycles/js-lib");
const got_1 = require("got");
const __1 = require("..");
const colors_1 = require("../colors");
/**
 * Returns instance of Got with "reasonable defaults":
 *
 * 1. Error handler hook that prints helpful errors.
 * 2. Hooks that log start/end of request (optional, false by default).
 * 3. Reasonable defaults(tm), e.g non-infinite Timeout
 */
function getGot(opt = {}) {
    opt.logger || (opt.logger = console);
    return got_1.default.extend({
        // Most-important is to set to anything non-empty (so, requests don't "hang" by default).
        // Should be long enough to handle for slow responses from scaled cloud APIs in times of spikes
        // Ideally should be LESS than default Request timeout in backend-lib (so, it has a chance to error
        // before server times out with 503).
        timeout: 90000,
        ...opt,
        hooks: {
            ...opt.hooks,
            beforeError: [
                ...(opt.hooks?.beforeError || []),
                // User hooks go BEFORE
                gotErrorHook(opt),
            ],
            beforeRequest: [
                gotBeforeRequestHook(opt),
                // User hooks go AFTER
                ...(opt.hooks?.beforeRequest || []),
            ],
            afterResponse: [
                ...(opt.hooks?.afterResponse || []),
                // User hooks go BEFORE
                gotAfterResponseHook(opt),
            ],
        },
    });
}
exports.getGot = getGot;
/**
 * Without this hook (default behaviour):
 *
 * HTTPError: Response code 422 (Unprocessable Entity)
 *  at EventEmitter.<anonymous> (.../node_modules/got/dist/source/as-promise.js:118:31)
 *  at processTicksAndRejections (internal/process/task_queues.js:97:5) {
 *  name: 'HTTPError'
 *
 *
 * With this hook:
 *
 * HTTPError 422 GET http://a.com/err?q=1 in 8 ms
 * {
 *   message: 'Reference already exists',
 *   documentation_url: 'https://developer.github.com/v3/git/refs/#create-a-reference'
 * }
 *
 * Features:
 * 1. Includes original method and URL (including e.g searchParams) in the error message.
 * 2. Includes response.body in the error message (limited length).
 * 3. Auto-detects and parses JSON response body (limited length).
 * 4. Includes time spent (gotBeforeRequestHook must also be enabled).
 * UPD: excluded now to allow automatic Sentry error grouping
 */
function gotErrorHook(opt = {}) {
    const { maxResponseLength = 10000 } = opt;
    return err => {
        if (err instanceof got_1.HTTPError) {
            const { statusCode } = err.response;
            const { method, url, prefixUrl } = err.options;
            const shortUrl = getShortUrl(opt, url, prefixUrl);
            // const { started } = context as GotRequestContext
            const body = (0, __1.inspectAny)(err.response.body, {
                maxLen: maxResponseLength,
                colors: false,
            });
            // timings are not part of err.message to allow automatic error grouping in Sentry
            err.message = [[statusCode, method, shortUrl].filter(Boolean).join(' '), body]
                .filter(Boolean)
                .join('\n');
        }
        return err;
    };
}
function gotBeforeRequestHook(opt) {
    return options => {
        options.context = {
            ...options.context,
            started: Date.now(),
        };
        if (opt.logStart) {
            const shortUrl = getShortUrl(opt, options.url, options.prefixUrl);
            opt.logger.log([(0, colors_1.dimGrey)(' >>'), (0, colors_1.dimGrey)(options.method), (0, colors_1.grey)(shortUrl)].join(' '));
        }
    };
}
function gotAfterResponseHook(opt = {}) {
    return resp => {
        const success = resp.statusCode >= 200 && resp.statusCode < 400;
        if (opt.logFinished) {
            const { started } = resp.request.options.context;
            const { url, prefixUrl, method } = resp.request.options;
            const shortUrl = getShortUrl(opt, url, prefixUrl);
            opt.logger.log([
                (0, colors_1.dimGrey)(' <<'),
                coloredHttpCode(resp.statusCode),
                (0, colors_1.dimGrey)(method),
                (0, colors_1.grey)(shortUrl),
                started && (0, colors_1.dimGrey)('in ' + (0, js_lib_1._since)(started)),
            ]
                .filter(Boolean)
                .join(' '));
            // console.log(`afterResp! ${resp.request.options.method} ${resp.url}`, { context: resp.request.options.context })
        }
        // Error responses are not logged, cause they're included in Error message already
        if (opt.logResponse && success) {
            opt.logger.log((0, __1.inspectAny)(resp.body, { maxLen: opt.maxResponseLength }));
        }
        return resp;
    };
}
function coloredHttpCode(statusCode) {
    if (statusCode < 400)
        return (0, colors_1.dimGrey)(statusCode); // default
    if (statusCode < 500)
        return (0, colors_1.yellow)(statusCode);
    return (0, colors_1.red)(statusCode);
}
function getShortUrl(opt, url, prefixUrl) {
    let shortUrl = url.toString();
    if (opt.logWithSearchParams === false) {
        shortUrl = shortUrl.split('?')[0];
    }
    if (opt.logWithPrefixUrl === false && prefixUrl && shortUrl.startsWith(prefixUrl)) {
        shortUrl = shortUrl.slice(prefixUrl.length);
    }
    return shortUrl;
}
