"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformMap2 = exports.notNullishPredicate = void 0;
const stream_1 = require("stream");
const js_lib_1 = require("@naturalcycles/js-lib");
const colors_1 = require("../../../colors");
function notNullishPredicate(item) {
    return item !== undefined && item !== null;
}
exports.notNullishPredicate = notNullishPredicate;
/**
 * Like pMap, but for streams.
 * Inspired by `through2`.
 * Main feature is concurrency control (implemented via `through2-concurrent`) and convenient options.
 * Using this allows native stream .pipe() to work and use backpressure.
 *
 * Only works in objectMode (due to through2Concurrent).
 *
 * Concurrency defaults to 16.
 *
 * If an Array is returned by `mapper` - it will be flattened and multiple results will be emitted from it. Tested by Array.isArray().
 */
function transformMap2(mapper, opt = {}) {
    const { concurrency = 16, predicate = notNullishPredicate, errorMode = js_lib_1.ErrorMode.THROW_IMMEDIATELY, flattenArrayOutput, onError, beforeFinal, metric = 'stream', logger = console, } = opt;
    let index = -1;
    let isRejected = false;
    let errors = 0;
    const collectedErrors = []; // only used if errorMode == THROW_AGGREGATED
    const q = new js_lib_1.PQueue({
        concurrency,
        resolveOn: 'start',
        // debug: true,
    });
    return new stream_1.Transform({
        objectMode: true,
        async final(cb) {
            // console.log('transformMap final', {index}, q.inFlight, q.queueSize)
            // wait for the current inFlight jobs to complete and push their results
            await q.onIdle();
            logErrorStats(logger, true);
            await beforeFinal?.(); // call beforeFinal if defined
            if (collectedErrors.length) {
                // emit Aggregated error
                cb(new js_lib_1.AggregatedError(collectedErrors));
            }
            else {
                // emit no error
                cb();
            }
        },
        async transform(chunk, _encoding, cb) {
            index++;
            // console.log('transform', {index})
            // Stop processing if THROW_IMMEDIATELY mode is used
            if (isRejected && errorMode === js_lib_1.ErrorMode.THROW_IMMEDIATELY)
                return cb();
            let calledBack = false;
            // Allow up to 1 x concurrency "buffer" (aka highWatermark)
            if (q.queueSize < concurrency) {
                cb();
                calledBack = true;
            }
            await q.push(async () => {
                try {
                    const currentIndex = index; // because we need to pass it to 2 functions - mapper and predicate. Refers to INPUT index (since it may return multiple outputs)
                    const res = await mapper(chunk, currentIndex);
                    const passedResults = await (0, js_lib_1.pFilter)(flattenArrayOutput && Array.isArray(res) ? res : [res], async (r) => await predicate(r, currentIndex));
                    passedResults.forEach(r => this.push(r));
                }
                catch (err) {
                    logger.error(err);
                    errors++;
                    logErrorStats(logger);
                    if (onError) {
                        try {
                            onError(err, chunk);
                        }
                        catch { }
                    }
                    if (errorMode === js_lib_1.ErrorMode.THROW_IMMEDIATELY) {
                        isRejected = true;
                        // Emit error immediately
                        // return cb(err as Error)
                        return this.emit('error', err);
                    }
                    if (errorMode === js_lib_1.ErrorMode.THROW_AGGREGATED) {
                        collectedErrors.push(err);
                    }
                }
            });
            // Resolved, which means it STARTED processing
            // This means we can take more load
            if (!calledBack) {
                cb();
            }
        },
    });
    function logErrorStats(logger, final = false) {
        if (!errors)
            return;
        logger.log(`${metric} ${final ? 'final ' : ''}errors: ${(0, colors_1.yellow)(errors)}`);
    }
}
exports.transformMap2 = transformMap2;
