"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logExec = exports.execShell = exports.execWithArgs = exports.execCommand = exports.proxyCommand = void 0;
const execa = require("execa");
const colors_1 = require("../colors");
async function proxyCommand(cmd, args = [], opt = {}) {
    const processArgs = process.argv.slice(2);
    await execWithArgs(cmd, [...args, ...processArgs], {
        ...opt,
    });
}
exports.proxyCommand = proxyCommand;
async function execCommand(cmd, opt = {}) {
    logExec(cmd, [], opt);
    await execa
        .command(cmd, {
        stdio: 'inherit',
        preferLocal: true,
        ...opt,
    })
        .catch(err => handleError(err, cmd, opt));
}
exports.execCommand = execCommand;
async function execWithArgs(cmd, args = [], opt = {}) {
    logExec(cmd, args, opt);
    await execa(cmd, args, {
        stdio: 'inherit',
        preferLocal: true,
        ...opt,
    }).catch(err => handleError(err, cmd, opt));
}
exports.execWithArgs = execWithArgs;
async function execShell(cmd, opt = {}) {
    await execCommand(cmd, {
        shell: true,
        ...opt,
    });
}
exports.execShell = execShell;
function handleError(err, cmd, opt = {}) {
    if (opt.noProcessExit) {
        throw err || new Error(`execCommand failed: ${cmd}`);
    }
    if (err) {
        if (err.originalMessage) {
            console.log((0, colors_1.dimGrey)(err.originalMessage));
        }
        else if (err.shortMessage) {
            console.log((0, colors_1.dimGrey)(err.shortMessage));
        }
        else {
            console.error(err);
        }
        if (err.exitCode) {
            process.exit(err.exitCode);
        }
    }
    process.exit(1);
}
function logExec(cmd, args = [], opt = {}) {
    const cmdline = [
        ...Object.entries(opt.env || {}).map(([k, v]) => [k, v].join('=')),
        cmd,
        ...args,
    ].join(' ');
    console.log((0, colors_1.grey)(cmdline));
}
exports.logExec = logExec;
