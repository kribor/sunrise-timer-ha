"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runJest = exports.isRunningAllTests = exports.getJestManualConfigPath = exports.getJestIntegrationConfigPath = exports.getJestConfigPath = void 0;
const fs = require("fs");
const js_lib_1 = require("@naturalcycles/js-lib");
const colors_1 = require("@naturalcycles/nodejs-lib/dist/colors");
const exec_1 = require("@naturalcycles/nodejs-lib/dist/exec");
const paths_cnst_1 = require("../cnst/paths.cnst");
const test_util_1 = require("./test.util");
function getJestConfigPath() {
    return fs.existsSync(`./jest.config.js`) ? undefined : `${paths_cnst_1.cfgDir}/jest.config.js`;
}
exports.getJestConfigPath = getJestConfigPath;
function getJestIntegrationConfigPath() {
    return fs.existsSync(`./jest.integration-test.config.js`)
        ? `./jest.integration-test.config.js`
        : `${paths_cnst_1.cfgDir}/jest.integration-test.config.js`;
}
exports.getJestIntegrationConfigPath = getJestIntegrationConfigPath;
function getJestManualConfigPath() {
    return fs.existsSync(`./jest.manual-test.config.js`)
        ? `./jest.manual-test.config.js`
        : `${paths_cnst_1.cfgDir}/jest.manual-test.config.js`;
}
exports.getJestManualConfigPath = getJestManualConfigPath;
/**
 * Detects if jest is run with all tests, or with specific tests.
 */
function isRunningAllTests() {
    const args = process.argv.slice(2);
    const positionalArgs = args.filter(a => !a.startsWith('-'));
    // console.log(process.argv, positionalArgs)
    return !positionalArgs.length;
}
exports.isRunningAllTests = isRunningAllTests;
/**
 * 1. Adds `--silent` if running all tests at once.
 */
async function runJest(opt = {}) {
    if (!(0, test_util_1.nodeModuleExists)('jest')) {
        console.log((0, colors_1.dimGrey)(`node_modules/${(0, colors_1.white)('jest')} not found, skipping tests`));
        return;
    }
    const { ci, integration, manual, leaks } = opt;
    const processArgs = process.argv.slice(2);
    // console.log(processArgs) // todo: solve to run it in dev-lib
    // Allow to override --maxWorkers
    let maxWorkers = processArgs.find(a => a.startsWith('--maxWorkers'));
    const args = ['--logHeapUsage', '--passWithNoTests', ...processArgs];
    const env = {
        TZ: process.env.TZ || 'UTC',
        DEBUG_COLORS: '1',
    };
    let jestConfig;
    if (manual) {
        jestConfig = getJestManualConfigPath();
    }
    else if (integration) {
        jestConfig = getJestIntegrationConfigPath();
    }
    else {
        jestConfig = getJestConfigPath();
    }
    if (jestConfig) {
        args.push(`--config=${jestConfig}`);
    }
    if (ci) {
        args.push('--ci', '--coverage');
        maxWorkers = maxWorkers || '--maxWorkers=2';
    }
    // Running all tests - will use `--silent` to suppress console-logs, will also set process.env.JEST_SILENT=1
    if (ci || isRunningAllTests()) {
        args.push('--silent');
    }
    if (leaks) {
        args.push('--detectOpenHandles', '--detectLeaks');
        maxWorkers = maxWorkers || '--maxWorkers=1';
    }
    if (maxWorkers)
        args.push(maxWorkers);
    if (args.includes('--silent')) {
        Object.assign(env, {
            JEST_SILENT: '1',
        });
    }
    if (!integration && !manual && !process.env['APP_ENV']) {
        Object.assign(env, {
            APP_ENV: 'test',
        });
    }
    if (!process.env['JEST_NO_ALPHABETIC']) {
        args.push(`--testSequencer=${paths_cnst_1.cfgDir}/jest.alphabetic.sequencer.js`);
    }
    const { NODE_OPTIONS } = process.env;
    if (NODE_OPTIONS) {
        console.log(`${(0, colors_1.dimGrey)('NODE_OPTIONS: ' + NODE_OPTIONS)}`);
    }
    else {
        console.log(`${(0, colors_1.dimGrey)('NODE_OPTIONS are not defined')}`);
    }
    await (0, exec_1.execWithArgs)('jest', (0, js_lib_1._uniq)(args), {
        env,
    });
}
exports.runJest = runJest;
