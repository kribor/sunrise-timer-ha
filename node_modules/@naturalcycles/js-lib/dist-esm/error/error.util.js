import { AppError, _jsonParseIfPossible, _stringifyAny, } from '..';
/**
 * Useful to ensure that error in `catch (err) { ... }`
 * is indeed an Error (and not e.g `string` or `undefined`).
 * 99% of the cases it will be Error already.
 * Becomes more useful since TypeScript 4.4 made `err` of type `unknown` by default.
 *
 * Alternatively, if you're sure it's Error - you can use `_assertIsError(err)`.
 */
export function _anyToError(o, opt) {
    if (o instanceof Error) {
        // Already an Error - return as-is
        return o;
    }
    const message = _stringifyAny(o, opt);
    return new Error(message);
}
/**
 * Converts "anything" to ErrorObject.
 * Detects if it's HttpErrorResponse, HttpErrorObject, ErrorObject, Error, etc..
 * If object is Error - Error.message will be used.
 * Objects (not Errors) get converted to prettified JSON string (via `_stringifyAny`).
 */
export function _anyToErrorObject(o, opt) {
    if (o instanceof Error) {
        return _errorToErrorObject(o, opt === null || opt === void 0 ? void 0 : opt.includeErrorStack);
    }
    o = _jsonParseIfPossible(o);
    if (_isHttpErrorResponse(o)) {
        return o.error;
    }
    if (_isErrorObject(o)) {
        return o;
    }
    // Here we are sure it has no `data` property,
    // so, fair to return `data: {}` in the end
    // Also we're sure it includes no "error name", e.g no `Error: ...`,
    // so, fair to include `name: 'Error'`
    const message = _stringifyAny(o, Object.assign({ includeErrorData: true }, opt));
    return {
        name: 'Error',
        message,
        data: {}, // empty
    };
}
export function _errorToErrorObject(e, includeErrorStack = false) {
    const obj = {
        name: e.name,
        message: e.message,
        data: Object.assign({}, e.data), // empty by default
    };
    if (includeErrorStack) {
        obj.stack = e.stack;
    }
    return obj;
}
export function _errorObjectToAppError(o) {
    const err = Object.assign(new AppError(o.message, o.data), {
    // name: err.name, // cannot be assigned to a readonly property like this
    // stack: o.stack, // also readonly e.g in Firefox
    });
    Object.defineProperty(err, 'name', {
        value: o.name,
        configurable: true,
    });
    Object.defineProperty(err, 'stack', {
        value: o.stack,
    });
    return err;
}
export function _isHttpErrorResponse(o) {
    return _isHttpErrorObject(o === null || o === void 0 ? void 0 : o.error);
}
export function _isHttpErrorObject(o) {
    var _a;
    return (typeof (o === null || o === void 0 ? void 0 : o.name) === 'string' &&
        typeof (o === null || o === void 0 ? void 0 : o.message) === 'string' &&
        typeof ((_a = o === null || o === void 0 ? void 0 : o.data) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 'number');
}
export function _isErrorObject(o) {
    return (typeof (o === null || o === void 0 ? void 0 : o.name) === 'string' && typeof (o === null || o === void 0 ? void 0 : o.message) === 'string' && typeof (o === null || o === void 0 ? void 0 : o.data) === 'object');
}
