import { _since, _stringifyAny } from '..';
/**
 * Returns a Function (!), enhanced with retry capabilities.
 * Implements "Exponential back-off strategy" by multiplying the delay by `delayMultiplier` with each try.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function pRetry(fn, opt = {}) {
    const { maxAttempts = 4, delay: initialDelay = 1000, delayMultiplier = 2, predicate, logger = console, } = opt;
    let { logFirstAttempt = false, logRetries = true, logFailures = false, logSuccess = false } = opt;
    if (opt.logAll) {
        logFirstAttempt = logRetries = logFailures = true;
    }
    if (opt.logNone) {
        logSuccess = logFirstAttempt = logRetries = logFailures = false;
    }
    const fname = ['pRetry', fn.name].filter(Boolean).join('.');
    return async function (...args) {
        let delay = initialDelay;
        let attempt = 0;
        return await new Promise((resolve, reject) => {
            const next = async () => {
                const started = Date.now();
                try {
                    attempt++;
                    if ((attempt === 1 && logFirstAttempt) || (attempt > 1 && logRetries)) {
                        logger.log(`${fname} attempt #${attempt}...`);
                    }
                    const r = await fn.apply(this, args);
                    if (logSuccess) {
                        logger.log(`${fname} attempt #${attempt} succeeded in ${_since(started)}`);
                    }
                    resolve(r);
                }
                catch (err) {
                    if (logFailures) {
                        logger.warn(`${fname} attempt #${attempt} error in ${_since(started)}:\n${_stringifyAny(err, {
                            includeErrorData: true,
                        })}`);
                    }
                    if (attempt >= maxAttempts || (predicate && !predicate(err, attempt, maxAttempts))) {
                        // Give up
                        reject(err);
                    }
                    else {
                        // Retry after delay
                        delay *= delayMultiplier;
                        setTimeout(next, delay);
                    }
                }
            };
            void next();
        });
    };
}
