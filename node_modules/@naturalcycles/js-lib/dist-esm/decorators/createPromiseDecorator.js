import { _getTargetMethodSignature } from './decorator.util';
/**
 * @example
 * // decorators.ts
 * export const BlockingLoader = () => _createPromiseDecorator({
 *   decoratorName: 'BlockingLoader',
 *   beforeFn: () => store.commit('setBlockingLoader'),
 *   finallyFn: () => store.commit('setBlockingLoader', false),
 * })
 *
 * @experimental
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
export function _createPromiseDecorator(cfg, decoratorParams = {}) {
    const { decoratorName } = cfg;
    return function decoratorFunction(target, propertyKey, pd) {
        // console.log(`@Decorator.${cfg.decoratorName} called: ` + propertyKey, pd, target)
        const originalMethod = pd.value;
        const key = String(propertyKey);
        const methodSignature = _getTargetMethodSignature(target, key);
        pd.value = async function (...args) {
            // console.log(`@${cfg.decoratorName} called inside function`)
            const started = Date.now();
            return (Promise.resolve()
                // Before function
                .then(() => {
                // console.log(`@${cfg.decoratorName} Before`)
                if (cfg.beforeFn) {
                    return cfg.beforeFn({
                        decoratorParams,
                        args,
                        key,
                        target,
                        decoratorName,
                        started,
                    });
                }
            })
                // Original function
                .then(() => originalMethod.apply(this, args))
                .then(res => {
                var _a;
                // console.log(`${cfg.decoratorName} After`)
                const resp = {
                    decoratorParams,
                    args,
                    key,
                    target,
                    decoratorName,
                    started,
                };
                if (cfg.thenFn) {
                    res = cfg.thenFn(Object.assign(Object.assign({}, resp), { res }));
                }
                (_a = cfg.finallyFn) === null || _a === void 0 ? void 0 : _a.call(cfg, resp);
                return res;
            })
                .catch(err => {
                var _a;
                console.error(`@${decoratorName} ${methodSignature} catch:`, err);
                const resp = {
                    decoratorParams,
                    args,
                    key,
                    target,
                    decoratorName,
                    started,
                };
                let handled = false;
                if (cfg.catchFn) {
                    cfg.catchFn(Object.assign(Object.assign({}, resp), { err }));
                    handled = true;
                }
                (_a = cfg.finallyFn) === null || _a === void 0 ? void 0 : _a.call(cfg, resp);
                if (!handled) {
                    throw err; // rethrow
                }
            })
            // es2018 only
            // .finally(() => {})
            );
        };
        return pd;
    };
}
