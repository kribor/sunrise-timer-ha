import { PropertyPath } from '../lodash.types';
import { AnyObject, ObjectMapper, ObjectPredicate, StringMap, ValueOf } from '../types';
/**
 * Returns clone of `obj` with only `props` preserved.
 * Opposite of Omit.
 */
export declare function _pick<T extends AnyObject, K extends keyof T>(obj: T, props: readonly K[], mutate?: boolean): T;
/**
 * Returns clone of `obj` with `props` omitted.
 * Opposite of Pick.
 */
export declare function _omit<T extends AnyObject, K extends keyof T>(obj: T, props: readonly K[], mutate?: boolean): T;
/**
 * Returns object with filtered keys from `props` array.
 * E.g:
 * _mask({...}, [
 *  'account.id',
 *  'account.updated',
 * ])
 */
export declare function _mask<T extends AnyObject>(obj: T, props: string[], mutate?: boolean): T;
/**
 * Removes "falsy" values from the object.
 */
export declare function _filterFalsyValues<T extends AnyObject>(obj: T, mutate?: boolean): T;
/**
 * Removes values from the object that are `null` or `undefined`.
 */
export declare function _filterNullishValues<T extends AnyObject>(obj: T, mutate?: boolean): T;
/**
 * Removes values from the object that are `undefined`.
 * Only `undefined` values are removed. `null` values are kept!
 */
export declare function _filterUndefinedValues<T extends AnyObject>(obj: T, mutate?: boolean): T;
export declare function _filterEmptyArrays<T extends AnyObject>(obj: T, mutate?: boolean): T;
/**
 * Returns clone of `obj` without properties that does not pass `predicate`.
 * Allows filtering by both key and value.
 */
export declare function _filterObject<T extends AnyObject>(obj: T, predicate: ObjectPredicate<T>, mutate?: boolean): T;
/**
 * var users = {
 *  'fred':    { 'user': 'fred',    'age': 40 },
 *  'pebbles': { 'user': 'pebbles', 'age': 1 }
 * }
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age')
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
export declare function _mapValues<T extends AnyObject, OUT = T>(obj: T, mapper: ObjectMapper<T, any>, mutate?: boolean): OUT;
/**
 * _.mapKeys({ 'a': 1, 'b': 2 }, (key, value) => key + value)
 * // => { 'a1': 1, 'b2': 2 }
 *
 * Does not support `mutate` flag.
 */
export declare function _mapKeys<T extends AnyObject>(obj: T, mapper: ObjectMapper<T, string>): StringMap<T[keyof T]>;
/**
 * Maps object through predicate - a function that receives (k, v, obj)
 * k - key
 * v - value
 * obj - whole object
 *
 * Order of arguments in the predicate is different form _mapValues / _mapKeys!
 *
 * Predicate should return a _tuple_ [0, 1], where:
 * 0 - key of returned object (string)
 * 1 - value of returned object (any)
 *
 * If predicate returns falsy value (e.g undefined), or a tuple where key (first item) is falsy - then such key/value pair is ignored (filtered out).
 *
 * Non-string keys are passed via String(...)
 */
export declare function _mapObject<IN extends AnyObject, OUT>(obj: IN, mapper: ObjectMapper<IN, [key: string, value: any]>): {
    [P in keyof IN]: OUT;
};
export declare function _findKeyByValue<T extends AnyObject>(obj: T, v: ValueOf<T>): keyof T | undefined;
export declare function _objectNullValuesToUndefined<T extends AnyObject>(obj: T, mutate?: boolean): T;
/**
 * Deep copy object (by json parse/stringify, since it has unbeatable performance+simplicity combo).
 */
export declare function _deepCopy<T>(o: T): T;
/**
 * Returns true if item is Object, not null and not Array.
 */
export declare function _isObject(item: any): item is AnyObject;
export declare function _isPrimitive(v: any): v is null | undefined | number | boolean | string;
export declare function _isEmptyObject(obj: any): boolean;
/**
 * Object is considered empty if it's one of:
 * undefined
 * null
 * '' (empty string)
 * [] (empty array)
 * {} (empty object)
 * new Map() (empty Map)
 * new Set() (empty Set)
 */
export declare function _isEmpty(obj: any): boolean;
/**
 * Returns `undefined` if it's empty (according to `_isEmpty()` specification),
 * otherwise returns the original object.
 */
export declare function _undefinedIfEmpty<T>(obj: T | undefined): T | undefined;
/**
 * Filters the object by removing all key-value pairs where Value is Empty (according to _isEmpty() specification).
 */
export declare function _filterEmptyValues<T extends AnyObject>(obj: T, mutate?: boolean): T;
/**
 * Recursively merges own and inherited enumerable properties of source
 * objects into the destination object, skipping source properties that resolve
 * to `undefined`. Array and plain object properties are merged recursively.
 * Other objects and value types are overridden by assignment. Source objects
 * are applied from left to right. Subsequent sources overwrite property
 * assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @category Object
 * @param target The destination object.
 * @param sources The source objects.
 * @returns Returns `object`.
 * @example
 *
 * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
 *
 * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
 *
 * _.merge(users, ages);
 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 *
 * Based on: https://gist.github.com/Salakar/1d7137de9cb8b704e48a
 */
export declare function _merge<T extends AnyObject>(target: T, ...sources: any[]): T;
/**
 * Trims all object VALUES deeply.
 * Doesn't touch object KEYS.
 * Mutates.
 */
export declare function _deepTrim<T extends AnyObject | string>(o: T): T;
export declare function _unset<T extends AnyObject>(obj: T, prop: string): void;
export declare function _invert<T extends AnyObject>(o: T): {
    [k in ValueOf<T>]: keyof T | undefined;
};
export declare function _invertMap<K, V>(m: ReadonlyMap<K, V>): Map<V, K>;
/**
 * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used
 * in its place.
 *
 * @param obj The object to query.
 * @param path The path of the property to get.
 * @param def The value returned if the resolved value is undefined.
 * @return Returns the resolved value.
 */
export declare function _get<T extends AnyObject>(obj?: T, path?: string, def?: any): any;
/**
 * Sets the value at path of object. If a portion of path doesn’t exist it’s created. Arrays are created for
 * missing index properties while objects are created for all other missing properties. Use _.setWith to
 * customize path creation.
 *
 * @param obj The object to modify.
 * @param path The path of the property to set.
 * @param value The value to set.
 * @return Returns object.
 *
 * Based on: https://stackoverflow.com/a/54733755/4919972
 */
export declare function _set<IN extends AnyObject, OUT = IN>(obj: IN, path: PropertyPath, value?: any): OUT;
/**
 * Checks if `path` is a direct property of `object` (not null, not undefined).
 *
 * @category Object
 * @param obj The object to query.
 * @param path The path to check.
 * @returns Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': { 'c': 3 } } };
 * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b.c');
 * // => true
 *
 * _.has(object, ['a', 'b', 'c']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
export declare function _has<T extends AnyObject>(obj: T, path?: string): boolean;
