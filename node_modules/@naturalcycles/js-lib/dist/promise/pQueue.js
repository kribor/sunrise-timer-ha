"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PQueue = void 0;
const errorMode_1 = require("../error/errorMode");
const pDefer_1 = require("./pDefer");
/**
 * Inspired by: https://github.com/sindresorhus/p-queue
 *
 * Allows to push "jobs" to the queue and control its concurrency.
 * Jobs are "promise-returning functions".
 *
 * API is @experimental
 */
class PQueue {
    constructor(cfg) {
        this.inFlight = 0;
        this.queue = [];
        this.onIdleListeners = [];
        this.cfg = {
            // concurrency: Number.MAX_SAFE_INTEGER,
            errorMode: errorMode_1.ErrorMode.THROW_IMMEDIATELY,
            logger: console,
            debug: false,
            resolveOn: 'finish',
            ...cfg,
        };
        if (!cfg.debug) {
            this.debug = () => { };
        }
    }
    debug(...args) {
        this.cfg.logger.log(...args);
    }
    get queueSize() {
        return this.queue.length;
    }
    /**
     * Returns a Promise that resolves when the queue is Idle (next time, since the call).
     * Resolves immediately in case the queue is Idle.
     * Idle means 0 queue and 0 inFlight.
     */
    onIdle() {
        if (this.queue.length === 0 && this.inFlight === 0)
            return Promise.resolve();
        const listener = (0, pDefer_1.pDefer)();
        this.onIdleListeners.push(listener);
        return listener;
    }
    /**
     * Push PromiseReturningFunction to the Queue.
     * Returns a Promise that resolves (or rejects) with the return value from the Promise.
     */
    push(fn_) {
        const { concurrency } = this.cfg;
        const resolveOnStart = this.cfg.resolveOn === 'start';
        const fn = fn_;
        fn.defer || (fn.defer = (0, pDefer_1.pDefer)());
        if (this.inFlight < concurrency) {
            // There is room for more jobs. Can start immediately
            this.inFlight++;
            this.debug(`inFlight++ ${this.inFlight}/${concurrency}, queue ${this.queue.length}`);
            if (resolveOnStart)
                fn.defer.resolve();
            fn()
                .then(result => {
                if (!resolveOnStart)
                    fn.defer.resolve(result);
            })
                .catch(err => {
                this.cfg.logger.error(err);
                if (resolveOnStart)
                    return;
                if (this.cfg.errorMode === errorMode_1.ErrorMode.SUPPRESS) {
                    fn.defer.resolve(); // resolve with `void`
                }
                else {
                    // Should be handled on the outside, otherwise it'll cause UnhandledRejection
                    fn.defer.reject(err);
                }
            })
                .finally(() => {
                this.inFlight--;
                this.debug(`inFlight-- ${this.inFlight}/${concurrency}, queue ${this.queue.length}`);
                // check if there's room to start next job
                if (this.queue.length && this.inFlight <= concurrency) {
                    const nextFn = this.queue.shift();
                    void this.push(nextFn);
                }
                else {
                    if (this.inFlight === 0) {
                        this.debug('onIdle');
                        this.onIdleListeners.forEach(defer => defer.resolve());
                        this.onIdleListeners.length = 0; // empty the array
                    }
                }
            });
        }
        else {
            this.queue.push(fn);
            this.debug(`inFlight ${this.inFlight}/${concurrency}, queue++ ${this.queue.length}`);
        }
        return fn.defer;
    }
}
exports.PQueue = PQueue;
