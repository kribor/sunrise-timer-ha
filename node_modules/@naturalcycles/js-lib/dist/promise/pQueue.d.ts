import { ErrorMode } from '../error/errorMode';
import { CommonLogger } from '../log/commonLogger';
export interface PQueueCfg {
    concurrency: number;
    /**
     * Default: THROW_IMMEDIATELY
     *
     * THROW_AGGREGATED is not supported.
     *
     * SUPPRESS_ERRORS will still log errors via logger. It will resolve the `.push` promise with void.
     */
    errorMode?: ErrorMode;
    /**
     * @default true
     */
    /**
     * Default to `console`
     */
    logger?: CommonLogger;
    /**
     * If true - will LOG EVERYTHING:)
     */
    debug?: boolean;
    /**
     * By default .push method resolves when the Promise is done (finished).
     *
     * If you set resolveOn = 'start' - .push method will resolve the Promise (with void) upon
     * the START of the processing.
     *
     * @default finish
     */
    resolveOn?: 'finish' | 'start';
}
export declare type PromiseReturningFunction<R> = () => Promise<R>;
/**
 * Inspired by: https://github.com/sindresorhus/p-queue
 *
 * Allows to push "jobs" to the queue and control its concurrency.
 * Jobs are "promise-returning functions".
 *
 * API is @experimental
 */
export declare class PQueue {
    constructor(cfg: PQueueCfg);
    private readonly cfg;
    private debug;
    inFlight: number;
    private queue;
    private onIdleListeners;
    get queueSize(): number;
    /**
     * Returns a Promise that resolves when the queue is Idle (next time, since the call).
     * Resolves immediately in case the queue is Idle.
     * Idle means 0 queue and 0 inFlight.
     */
    onIdle(): Promise<void>;
    /**
     * Push PromiseReturningFunction to the Queue.
     * Returns a Promise that resolves (or rejects) with the return value from the Promise.
     */
    push<R>(fn_: PromiseReturningFunction<R>): Promise<R>;
}
