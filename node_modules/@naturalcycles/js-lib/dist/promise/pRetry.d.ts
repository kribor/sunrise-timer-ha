import { CommonLogger } from '..';
export interface PRetryOptions {
    /**
     * How many attempts to try.
     * First attempt is not a retry, but "initial try". It still counts.
     * maxAttempts of 4 will be 1 try and 3 retries.
     *
     * @default 4
     */
    maxAttempts?: number;
    /**
     * @default 1000 ms
     */
    delay?: number;
    /**
     * @default 2
     */
    delayMultiplier?: number;
    /**
     * Called on every retry (since 2nd attempt, cause 1st attempt is not a retry).
     *
     * True - keep retrying.
     * False - stop retrying and return immediately.
     *
     * @default () => true
     */
    predicate?: (err: unknown, attempt: number, maxAttempts: number) => boolean;
    /**
     * Log the first attempt (which is not a "retry" yet).
     *
     * @default false
     */
    logFirstAttempt?: boolean;
    /**
     * Log retries - attempts that go after the first one.
     *
     * @default true
     */
    logRetries?: boolean;
    /**
     * @default false
     */
    logSuccess?: boolean;
    /**
     * @default true
     */
    logFailures?: boolean;
    /**
     * @default false
     */
    logAll?: boolean;
    /**
     * @default false
     */
    logNone?: boolean;
    /**
     * Default to `console`
     */
    logger?: CommonLogger;
}
/**
 * Returns a Function (!), enhanced with retry capabilities.
 * Implements "Exponential back-off strategy" by multiplying the delay by `delayMultiplier` with each try.
 */
export declare function pRetry<T extends Function>(fn: T, opt?: PRetryOptions): T;
