"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._TryCatch = exports._tryCatch = void 0;
const index_1 = require("../index");
/**
 * Decorates a function with "try/catch", so it'll never reject/throw.
 * Only applies to async functions (or, turns sync function into async).
 *
 * Allows to pass onError callback.
 *
 * @experimental
 */
function _tryCatch(fn, opt = {}) {
    const { onError, logError = true, logSuccess = false, logger = console } = opt;
    const fname = fn.name || 'anonymous';
    return async function (...args) {
        const started = Date.now();
        try {
            const r = await fn.apply(this, args);
            if (logSuccess) {
                logger.log(`tryCatch.${fname} succeeded in ${(0, index_1._since)(started)}`);
            }
            return r;
        }
        catch (err) {
            if (logError) {
                logger.warn(`tryCatch.${fname} error in ${(0, index_1._since)(started)}:\n${(0, index_1._stringifyAny)(err, {
                    includeErrorData: true,
                })}`);
            }
            if (onError) {
                try {
                    return await onError(err); // eslint-disable-line @typescript-eslint/return-await
                }
                catch { }
            }
            // returns undefined, but doesn't rethrow
        }
    };
}
exports._tryCatch = _tryCatch;
// eslint-disable-next-line @typescript-eslint/naming-convention
const _TryCatch = (opt = {}) => (target, key, descriptor) => {
    const originalFn = descriptor.value;
    descriptor.value = _tryCatch(originalFn, opt);
    return descriptor;
};
exports._TryCatch = _TryCatch;
