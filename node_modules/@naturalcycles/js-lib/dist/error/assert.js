"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssertionError = exports._assertTypeOf = exports._assertIsNumber = exports._assertIsString = exports._assertIsError = exports._assertDeepEquals = exports._assertEquals = exports._assert = void 0;
const __1 = require("..");
const app_error_1 = require("./app.error");
/**
 * Evaluates the `condition` (casts it to Boolean).
 * Expects it to be truthy, otherwise throws AppError.
 *
 * Should be used NOT for "expected" / user-facing errors, but
 * vice-versa - for completely unexpected and 100% buggy "should never happen" cases.
 *
 * It'll result in http 500 on the server (cause that's the right code for "unexpected" errors).
 * Pass { httpStatusCode: x } at errorData argument to override the http code (will be picked up by backend-lib).
 *
 * API is similar to Node's assert(), except:
 * 1. Throws js-lib's AppError
 * 2. Has a default message, if not provided
 * 3. Sets `userFriendly` flag to true, cause it's always better to have at least SOME clue, rather than fully generic "Oops" error.
 */
function _assert(condition, // will be evaluated as Boolean
message, errorData) {
    if (!condition) {
        throw new AssertionError(message || 'see stacktrace', {
            userFriendly: true,
            ...errorData,
        });
    }
}
exports._assert = _assert;
/**
 * Like _assert(), but prints more helpful error message.
 * API is similar to Node's assert.equals().
 *
 * Does SHALLOW, but strict equality (===), use _assertDeepEquals() for deep equality.
 */
function _assertEquals(actual, expected, message, errorData) {
    if (actual !== expected) {
        const msg = [
            message || 'not equal',
            `expected: ${(0, __1._stringifyAny)(expected)}`,
            `got     : ${(0, __1._stringifyAny)(actual)}`,
        ]
            .filter(Boolean)
            .join('\n');
        throw new AssertionError(msg, {
            userFriendly: true,
            ...errorData,
        });
    }
}
exports._assertEquals = _assertEquals;
/**
 * Like _assert(), but prints more helpful error message.
 * API is similar to Node's assert.deepEquals().
 *
 * Does DEEP equality via _deepEquals()
 */
function _assertDeepEquals(actual, expected, message, errorData) {
    if (!(0, __1._deepEquals)(actual, expected)) {
        const msg = [
            message || `not deeply equal`,
            `expected: ${(0, __1._stringifyAny)(expected)}`,
            `got     : ${(0, __1._stringifyAny)(actual)}`,
        ]
            .filter(Boolean)
            .join('\n');
        throw new AssertionError(msg, {
            userFriendly: true,
            ...errorData,
        });
    }
}
exports._assertDeepEquals = _assertDeepEquals;
function _assertIsError(err, message) {
    if (!(err instanceof Error)) {
        const msg = [message || `expected to be instanceof Error`, `actual typeof: ${typeof err}`].join('\n');
        throw new AssertionError(msg, {
            userFriendly: true,
        });
    }
}
exports._assertIsError = _assertIsError;
function _assertIsString(v, message) {
    _assertTypeOf(v, 'string', message);
}
exports._assertIsString = _assertIsString;
function _assertIsNumber(v, message) {
    _assertTypeOf(v, 'number', message);
}
exports._assertIsNumber = _assertIsNumber;
function _assertTypeOf(v, expectedType, message) {
    if (typeof v !== expectedType) {
        const msg = [
            message || `unexpected type`,
            `expected: ${expectedType}`,
            `got     : ${typeof v}`,
        ].join('\n');
        throw new AssertionError(msg, {
            userFriendly: true,
        });
    }
}
exports._assertTypeOf = _assertTypeOf;
class AssertionError extends app_error_1.AppError {
    constructor(message, data = {}) {
        super(message, data);
    }
}
exports.AssertionError = AssertionError;
