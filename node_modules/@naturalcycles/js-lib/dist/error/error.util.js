"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._isErrorObject = exports._isHttpErrorObject = exports._isHttpErrorResponse = exports._errorObjectToAppError = exports._errorToErrorObject = exports._anyToErrorObject = exports._anyToError = void 0;
const __1 = require("..");
/**
 * Useful to ensure that error in `catch (err) { ... }`
 * is indeed an Error (and not e.g `string` or `undefined`).
 * 99% of the cases it will be Error already.
 * Becomes more useful since TypeScript 4.4 made `err` of type `unknown` by default.
 *
 * Alternatively, if you're sure it's Error - you can use `_assertIsError(err)`.
 */
function _anyToError(o, opt) {
    if (o instanceof Error) {
        // Already an Error - return as-is
        return o;
    }
    const message = (0, __1._stringifyAny)(o, opt);
    return new Error(message);
}
exports._anyToError = _anyToError;
/**
 * Converts "anything" to ErrorObject.
 * Detects if it's HttpErrorResponse, HttpErrorObject, ErrorObject, Error, etc..
 * If object is Error - Error.message will be used.
 * Objects (not Errors) get converted to prettified JSON string (via `_stringifyAny`).
 */
function _anyToErrorObject(o, opt) {
    if (o instanceof Error) {
        return _errorToErrorObject(o, opt?.includeErrorStack);
    }
    o = (0, __1._jsonParseIfPossible)(o);
    if (_isHttpErrorResponse(o)) {
        return o.error;
    }
    if (_isErrorObject(o)) {
        return o;
    }
    // Here we are sure it has no `data` property,
    // so, fair to return `data: {}` in the end
    // Also we're sure it includes no "error name", e.g no `Error: ...`,
    // so, fair to include `name: 'Error'`
    const message = (0, __1._stringifyAny)(o, {
        includeErrorData: true,
        ...opt,
    });
    return {
        name: 'Error',
        message,
        data: {}, // empty
    };
}
exports._anyToErrorObject = _anyToErrorObject;
function _errorToErrorObject(e, includeErrorStack = false) {
    const obj = {
        name: e.name,
        message: e.message,
        data: { ...e.data }, // empty by default
    };
    if (includeErrorStack) {
        obj.stack = e.stack;
    }
    return obj;
}
exports._errorToErrorObject = _errorToErrorObject;
function _errorObjectToAppError(o) {
    const err = Object.assign(new __1.AppError(o.message, o.data), {
    // name: err.name, // cannot be assigned to a readonly property like this
    // stack: o.stack, // also readonly e.g in Firefox
    });
    Object.defineProperty(err, 'name', {
        value: o.name,
        configurable: true,
    });
    Object.defineProperty(err, 'stack', {
        value: o.stack,
    });
    return err;
}
exports._errorObjectToAppError = _errorObjectToAppError;
function _isHttpErrorResponse(o) {
    return _isHttpErrorObject(o?.error);
}
exports._isHttpErrorResponse = _isHttpErrorResponse;
function _isHttpErrorObject(o) {
    return (typeof o?.name === 'string' &&
        typeof o?.message === 'string' &&
        typeof o?.data?.httpStatusCode === 'number');
}
exports._isHttpErrorObject = _isHttpErrorObject;
function _isErrorObject(o) {
    return (typeof o?.name === 'string' && typeof o?.message === 'string' && typeof o?.data === 'object');
}
exports._isErrorObject = _isErrorObject;
