import { CommonLogger } from '../log/commonLogger';
import { MemoCache } from './memo.util';
export interface MemoOptions {
    /**
     * Default to false
     */
    logHit?: boolean;
    /**
     * Default to false
     */
    logMiss?: boolean;
    /**
     * Skip logging method arguments.
     */
    noLogArgs?: boolean;
    /**
     * Default to `console`
     */
    logger?: CommonLogger;
    /**
     * Provide a custom implementation of MemoCache.
     * Function that creates an instance of `MemoCache`.
     * e.g LRUMemoCache from `@naturalcycles/nodejs-lib`
     */
    cacheFactory?: () => MemoCache;
    /**
     * Provide a custom implementation of CacheKey function.
     */
    cacheKeyFn?: (args: any[]) => any;
    /**
     * Don't cache resolved promises.
     * Setting this to `true` will make the decorator to await the result.
     */
    noCacheResolved?: boolean;
    /**
     * Don't cache rejected promises.
     * Setting this to `true` will make the decorator to await the result.
     */
    noCacheRejected?: boolean;
}
/**
 * Memoizes the method of the class, so it caches the output and returns the cached version if the "key"
 * of the cache is the same. Key, by defaul, is calculated as `JSON.stringify(...args)`.
 * Cache is stored indefinitely in internal Map.
 *
 * Cache is stored **per instance** - separate cache for separate instances of the class.
 * If you don't want it that way - you can use a static method, then there will be only one "instance".
 *
 * Supports dropping it's cache by calling .dropCache() method of decorated function (useful in unit testing).
 */
export declare const _Memo: (opt?: MemoOptions) => MethodDecorator;
