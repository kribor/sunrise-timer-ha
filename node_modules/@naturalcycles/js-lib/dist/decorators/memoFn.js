"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._memoFn = void 0;
const time_util_1 = require("../time/time.util");
const decorator_util_1 = require("./decorator.util");
const memo_util_1 = require("./memo.util");
function _memoFn(fn, opt = {}) {
    const { logHit = false, logMiss = false, noLogArgs = false, logger = console, noCacheRejected = false, noCacheResolved = false, cacheFactory = () => new memo_util_1.MapMemoCache(), cacheKeyFn = memo_util_1.jsonMemoSerializer, } = opt;
    const cache = cacheFactory();
    const awaitPromise = Boolean(noCacheRejected || noCacheResolved);
    const fnName = fn.name;
    const memoizedFn = function (...args) {
        const ctx = this;
        const cacheKey = cacheKeyFn(args);
        if (cache.has(cacheKey)) {
            if (logHit) {
                logger.log(`${fnName}(${(0, decorator_util_1._getArgsSignature)(args, noLogArgs)}) memoFn hit`);
            }
            const res = cache.get(cacheKey);
            if (awaitPromise) {
                return res instanceof Error ? Promise.reject(res) : Promise.resolve(res);
            }
            else {
                return res;
            }
        }
        const started = Date.now();
        const res = fn.apply(ctx, args);
        if (awaitPromise) {
            return res
                .then(res => {
                // console.log('RESOLVED', res)
                if (logMiss) {
                    logger.log(`${fnName}(${(0, decorator_util_1._getArgsSignature)(args, noLogArgs)}) memoFn miss resolved (${(0, time_util_1._since)(started)})`);
                }
                if (!noCacheResolved) {
                    cache.set(cacheKey, res);
                }
                return res;
            })
                .catch(err => {
                // console.log('REJECTED', err)
                if (logMiss) {
                    logger.log(`${fnName}(${(0, decorator_util_1._getArgsSignature)(args, noLogArgs)}) memoFn miss rejected (${(0, time_util_1._since)(started)})`);
                }
                if (!noCacheRejected) {
                    // We put it to cache as raw Error, not Promise.reject(err)
                    // So, we'll need to check if it's instanceof Error to reject it or resolve
                    // Wrap as Error if it's not Error
                    cache.set(cacheKey, err instanceof Error ? err : new Error(err));
                }
                return Promise.reject(err);
            });
        }
        else {
            if (logMiss) {
                logger.log(`${fnName}(${(0, decorator_util_1._getArgsSignature)(args, noLogArgs)}) memoFn miss (${(0, time_util_1._since)(started)})`);
            }
            cache.set(cacheKey, res);
            return res;
        }
    };
    Object.assign(memoizedFn, { cache });
    return memoizedFn;
}
exports._memoFn = _memoFn;
