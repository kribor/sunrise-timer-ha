"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPlugins = exports.DAYJS_COMPACT_TIME_SECONDS = exports.DAYJS_COMPACT_TIME = exports.DAYJS_PRETTY_TIME_NO_SECONDS = exports.DAYJS_PRETTY_TIME = exports.DAYJS_TIME_HM = exports.DAYJS_TIME_HMS = exports.DAYJS_COMPACT_DATE = exports.DAYJS_ISO_DATE = void 0;
// todo: fix the interface extension
exports.DAYJS_ISO_DATE = 'YYYY-MM-DD';
exports.DAYJS_COMPACT_DATE = 'YYYYMMDD';
exports.DAYJS_TIME_HMS = 'HH:mm:ss';
exports.DAYJS_TIME_HM = 'HH:mm';
exports.DAYJS_PRETTY_TIME = 'YYYY-MM-DD HH:mm:ss';
exports.DAYJS_PRETTY_TIME_NO_SECONDS = 'YYYY-MM-DD HH:mm';
exports.DAYJS_COMPACT_TIME = 'YYYYMMDD_HHmm';
exports.DAYJS_COMPACT_TIME_SECONDS = 'YYYYMMDD_HHmmss';
const defaultPlugins = (_opt, dayjsClass, _dayjsFactory) => {
    dayjsClass.prototype.toISODate = function () {
        // return this.format(DAYJS_ISO_DATE)
        // `format` is fine, but benchmarks show that it's ~3 times slower than "manual" implementation:
        return `${this.year()}-${String(this.month() + 1).padStart(2, '0')}-${String(this.date()).padStart(2, '0')}`;
        // The other formats are not "perf-optimized", but you can use your own custom formatter implementations
        // in your project instead
    };
    dayjsClass.prototype.toPretty = function (seconds = true) {
        return this.format(seconds ? exports.DAYJS_PRETTY_TIME : exports.DAYJS_PRETTY_TIME_NO_SECONDS);
    };
    dayjsClass.prototype.toCompactTime = function (seconds = false) {
        return this.format(seconds ? exports.DAYJS_COMPACT_TIME_SECONDS : exports.DAYJS_COMPACT_TIME);
    };
    dayjsClass.prototype.toCompactDate = function () {
        return this.format(exports.DAYJS_COMPACT_DATE);
    };
    dayjsClass.prototype.unixMillis = function () {
        return this.valueOf();
    };
    dayjsClass.prototype.today = function () {
        return this.startOf('day');
    };
};
exports.defaultPlugins = defaultPlugins;
